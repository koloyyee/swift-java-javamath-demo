# A Hands-On Tutorial for Java Interop in Swift using `swift-java`

**You will find the complete version of `Package.swift` and `math.swift` in the end.**

## Goal

This tutorial gives a concise, hands-on introduction to using `swift-java` locally. You'll learn how to call Java core libraries like `BigInteger` and `Random` from Swift, including both instance and static methods.

---

## Add `swift-java` to Your Project

Let's begin by creating an executable project.

```sh
mkdir JavaMath
cd JavaMath
swift package init --name JavaMath --type executable
```

Next, let's create a Swift module:

```sh
mkdir Sources/JavaMath
touch Sources/JavaMath/math.swift
```

or in your editor right-click the `Sources`, then create `JavaMath` directory, and finally create new file `math.swift`

register the module in the `Package.swift`:

```swift
...
    platforms: [...],
    products: [
        .executable(name: "JavaMath", targets: ["JavaMath"])
    ],
    dependencies: [...],
...
```

add dependencies:

```sh
# add swift-java library.
swift package add-dependency https://github.com/swiftlang/swift-java --branch main

# add swift-argument-parser for our CLI executable.
swift package add-dependency https://github.com/apple/swift-argument-parser.git --from 1.6.1
```

Add platforms macOS v15+ to `Package.swift`.
Add `plugins` and `dependencies` to `.executableTarget`.

```swift
...
    name: "my-swift-java",
     platforms: [
        .macOS(.v15),
    ],
    dependencies: [
        .package(url: "https://github.com/swiftlang/swift-java", branch: "main"),
        .package(url: "https://github.com/apple/swift-argument-parser.git", from: "1.6.1"),
    ],
    targets: [
        // Targets are the basic building blocks of a package, defining a module or a test suite.
        // Targets can depend on other targets in this package and products from dependencies.
        .executableTarget(
            name: "JavaMath", // our Swift Module Name
            dependencies: [
        .product(name: "JavaUtil", package: "swift-java"),
                .product(name: "SwiftJava", package: "swift-java"),
                .product(name: "CSwiftJavaJNI", package: "swift-java"),
                .product(
                    name: "ArgumentParser",
                    package: "swift-argument-parser"
                ),
            ],
            plugins: [
                .plugin(name: "SwiftJavaPlugin", package: "swift-java")
            ],
        )
    ]
...

```

Since we need to access the Java Virtual Machine, this setup helps us locate the correct `JAVA_HOME` path:

```swift
import CompilerPluginSupport
import PackageDescription

import class Foundation.FileManager
import class Foundation.ProcessInfo

// Note: the JAVA_HOME environment variable must be set to point to where
// Java is installed, e.g.,
//   Library/Java/JavaVirtualMachines/openjdk-21.jdk/Contents/Home.
func findJavaHome() -> String {
  if let home = ProcessInfo.processInfo.environment["JAVA_HOME"] {
    return home
  }

  // This is a workaround for envs (some IDEs) which have trouble with
  // picking up env variables during the build process
  let path = "\(FileManager.default.homeDirectoryForCurrentUser.path()).java_home"
  if let home = try? String(contentsOfFile: path, encoding: .utf8) {
    if let lastChar = home.last, lastChar.isNewline {
      return String(home.dropLast())
    }

    return home
  }

  fatalError("Please set the JAVA_HOME environment variable to point to where Java is installed.")
}
let javaHome = findJavaHome()

let javaIncludePath = "\(javaHome)/include"
#if os(Linux)
  let javaPlatformIncludePath = "\(javaIncludePath)/linux"
#elseif os(macOS)
  let javaPlatformIncludePath = "\(javaIncludePath)/darwin"
#else
  #error("Currently only macOS and Linux platforms are supported, this may change in the future.")
#endif
...

let package = Package(
...
        .executableTarget(
            name: "...",
            dependencies: [...],
            swift-java.config
            )
...
)
```

---

Create file `swift-java.config` in `JavaMath` directory:

```sh
touch Sources/JavaMath/swift-java.config
```

Add the following to the `swift-java.config` file:

```json
{
  "classes": {
    "java.math.BigInteger": "BigInteger"
  }
}
```

Let's build it in the terminal:

```sh
swift build
```

`swift-java` SwiftPM plugin will generate a wrapper `.swift` file for the Java `BigInteger`.
To find it go to `.build/plugins/outputs/myswiftjava/JavaMath/destination/SwiftJavaPlugin/generated/BigInteger.swift`

```swift
// Auto-generated by Java-to-Swift wrapper generator.
import CSwiftJavaJNI
import SwiftJava

@JavaClass("java.math.BigInteger")
open class BigInteger: JavaNumber {
  ...
}
```

## Using Java in Swift

Now, let's use the Java `BigInteger` in Swift:

```swift
import SwiftJava
import ArgumentParser

@main
struct JavaMath : ParsableCommand{
    @Argument(help: "The number to check for primality")
    var number: String

    @Option(help: "The certainty to require in the prime check")
    var certainty: Int32 = 10

    func run() throws {

        let bigInt = BigInteger(number)
        let total = plusOne( bigInt)
        print("Total: \(total)")
        print(probablyPrime(BigInteger("\(total)")))
    }

   func plusOne(_ bigInt: BigInteger) -> Int32 {
        let bigTwo = bigInt.add(BigInteger("1"))
        guard let result = bigTwo else {
            return bigInt.intValue()
        }
        return result.intValue()
    }

    func probablyPrime(_ bigInt: BigInteger) -> Bool {
        return bigInt.isProbablePrime(certainty)
    }
}
```

Run it!

```
swift run JavaMath 2
```

```sh
#output
Total: 3
true
```

Let's add another Java util package:

```json
{
  "classes": {
    "java.util.Random": "Random",
    "java.math.BigInteger": "BigInteger"
  }
}
```

Let's try to use the static method from `BigInteger` and access JNI environment

```swift
...
 .executableTarget(
     name: "JavaMath", // our Swift Module Name
     dependencies: [
         .product(name: "JavaUtil", package: "swift-java"), // add this
         .product(name: "SwiftJava", package: "swift-java"),
         .product(name: "CSwiftJavaJNI", package: "swift-java"),
         .product(
             name: "ArgumentParser",
             package: "swift-argument-parser"
         ),
     ],
     plugins: [
         .plugin(name: "SwiftJavaPlugin", package: "swift-java")
     ],
 )
...

```

Why do we need Random?

To use the probablePrime() static method, 2 arguments are needed. First is the bitLength(int), second is the rnd(Random).

You can find out more here: probablePrime Java doc

Add the following snippet:

```swift
...
func run() throws {
  ...
  // Static Method in Java
  let javaVirtualMachine = try JavaVirtualMachine.shared()
  let jniEnvironment = try javaVirtualMachine.environment()

  let bigIntClass = try JavaClass<BigInteger>(environment: jniEnvironment)
  let rand = Random(environment: jniEnvironment)
    if let isPrime = bigIntClass.probablePrime(total, rand) {
      print("It is prime! \(isPrime.intValue())")
  } else {
    print("Not Prime")
  }
}
```

Run it!

```
swift run JavaMath 2
```

```sh
#output
Total: 3
true
5
```

Your `Sources/JavaMath/math.swift` should look like this:

```swift
import ArgumentParser
import SwiftJava

@main
struct JavaMath: ParsableCommand {
    @Argument(help: "The number to check for primality")
    var number: String

    @Option(help: "The certainty to require in the prime check")
    var certainty: Int32 = 10

    func run() throws {

        // Using Java BigInteger
        let bigInt = BigInteger(number)

        // Instance Method
        let total = plusOne(bigInt)
        print("Total: \(total)")
        print(probablyPrime(BigInteger("\(total)")))

        // Accessing JVM
        let javaVirtualMachine = try JavaVirtualMachine.shared()
        let jniEnvironment = try javaVirtualMachine.environment()

        // Static Method
        let bigIntClass = try JavaClass<BigInteger>(environment: jniEnvironment)
        let rand = Random(environment: jniEnvironment)
        if let isPrime = bigIntClass.probablePrime(total, rand) {
            print(isPrime.intValue())
        }
    }

    func plusOne(_ bigInt: BigInteger) -> Int32 {
        let bigTwo = bigInt.add(BigInteger("1"))
        guard let result = bigTwo else {
            return bigInt.intValue()
        }
        return result.intValue()
    }

    func probablyPrime(_ bigInt: BigInteger) -> Bool {
        let result =  bigInt.isProbablePrime(certainty)
        if result {
          print("This is a prime number")
        } else {
          print("Proabaly not prime.")
        }
        return result
    }
}

```

Your `Package.swift` should look like this:

```swift
// swift-tools-version: 6.1
// The swift-tools-version declares the minimum version of Swift required to build this package.

import CompilerPluginSupport
import PackageDescription

import class Foundation.FileManager
import class Foundation.ProcessInfo

import CompilerPluginSupport
import PackageDescription

import class Foundation.FileManager
import class Foundation.ProcessInfo

// Note: the JAVA_HOME environment variable must be set to point to where
// Java is installed, e.g.,
//   Library/Java/JavaVirtualMachines/openjdk-21.jdk/Contents/Home.
func findJavaHome() -> String {
  if let home = ProcessInfo.processInfo.environment["JAVA_HOME"] {
    return home
  }

  // This is a workaround for envs (some IDEs) which have trouble with
  // picking up env variables during the build process
  let path = "\(FileManager.default.homeDirectoryForCurrentUser.path()).java_home"
  if let home = try? String(contentsOfFile: path, encoding: .utf8) {
    if let lastChar = home.last, lastChar.isNewline {
      return String(home.dropLast())
    }

    return home
  }

  fatalError("Please set the JAVA_HOME environment variable to point to where Java is installed.")
}
let javaHome = findJavaHome()

let javaIncludePath = "\(javaHome)/include"
#if os(Linux)
  let javaPlatformIncludePath = "\(javaIncludePath)/linux"
#elseif os(macOS)
  let javaPlatformIncludePath = "\(javaIncludePath)/darwin"
#else
  #error("Currently only macOS and Linux platforms are supported, this may change in the future.")
#endif

let package = Package(
    name: "my-swift-java",
    platforms: [
        .macOS(.v15),
        .iOS(.v18),
        .watchOS(.v11),
        .tvOS(.v18),
    ],
    products: [
        .executable(name: "JavaMath", targets: ["JavaMath"])
    ],
    dependencies: [
        .package(
            url: "https://github.com/swiftlang/swift-java",
            branch: "main"
        ),
        .package(
            url: "https://github.com/apple/swift-argument-parser.git",
            from: "1.6.1"
        ),
    ],
    targets: [
        // Targets are the basic building blocks of a package, defining a module or a test suite.
        // Targets can depend on other targets in this package and products from dependencies.
        .executableTarget(
            name: "JavaMath",
            dependencies: [
                .product(name: "JavaUtil", package: "swift-java"),
                .product(name: "SwiftJava", package: "swift-java"),
                .product(name: "CSwiftJavaJNI", package: "swift-java"),
                .product(
                    name: "ArgumentParser",
                    package: "swift-argument-parser"
                ),
            ],
            exclude: ["swift-java.config"],
                  swiftSettings: [
                    .unsafeFlags(["-I\(javaIncludePath)", "-I\(javaPlatformIncludePath)"]),
                    .swiftLanguageMode(.v5),
                  ],
            plugins: [
                .plugin(name: "SwiftJavaPlugin", package: "swift-java")
            ],
        )
    ]
)

```

## Conclusion

You now have a working example that demonstrates how to call Java from Swift using `swift-java`. We covered project setup, generating Java-to-Swift wrappers, calling instance methods, invoking static methods, and accessing the JVM environment when needed.

### Next steps

- Explore the `Samples` directory for more examples, including how to use the `swift-java` command-line tools, work with FFM and JNI, integrate popular Java libraries (for example, Apache Commons CSV), and embed Swift into Java projects.
